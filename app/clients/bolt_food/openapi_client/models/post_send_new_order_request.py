# coding: utf-8

"""
    BoltFoodAPI

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.generic_pos_api_price import GenericPosApiPrice
from openapi_client.models.generic_pos_dine_in_details import GenericPosDineInDetails
from openapi_client.models.generic_pos_item import GenericPosItem
from openapi_client.models.generic_pos_price import GenericPosPrice
from openapi_client.models.generic_pos_user_info import GenericPosUserInfo
from typing import Optional, Set
from typing_extensions import Self

class PostSendNewOrderRequest(BaseModel):
    """
    PostSendNewOrderRequest
    """ # noqa: E501
    provider_id: StrictStr = Field(description="A unique string identifier of the provider  (contact Bolt Food support to obtain one) ")
    order_id: StrictInt = Field(description="A numeric identifier of an order, provided by Bolt Food")
    extended_order_id: Optional[StrictStr] = Field(default=None, description="The id used for Dine In Orders.  It is built using the following format:  `\"${main_order_id}_${item_group_id}\"` ")
    order_reference_id: StrictStr = Field(description="Bolt Food order reference id is a short alphanumerical string that identifies the order")
    order_type: StrictStr = Field(description="The type of the order based on how it is delivered")
    order_dispatch_type: Optional[StrictStr] = Field(default=None, description="The dispatch type of the order specific for the scheduled orders feature _(you can enable this feature by contacting Bolt Food)_")
    payment_type: StrictStr = Field(description="The type of payment chose by the Bolt Food customer")
    created_ts: Union[StrictFloat, StrictInt] = Field(description="The UNIX timestamp in **seconds** when the order has been created")
    created_datetime: StrictStr = Field(description="The ISO datetime in the restaurant's timezone when the order has been created")
    due_ts: Union[StrictFloat, StrictInt] = Field(description="The UNIX timestamp in **seconds** when the order needs to be ready for pick up")
    due_datetime: StrictStr = Field(description="The ISO datetime in the restaurant's timezone when the order needs to be ready for pick up")
    customer: GenericPosUserInfo = Field(description="A `GenericPosUserInfo` object that contains information about the customer")
    items: List[GenericPosItem] = Field(description="Array of `GenericPosItem` objects")
    total_order_price: GenericPosApiPrice = Field(description="The total price of the order")
    delivery_fee: Optional[GenericPosApiPrice] = Field(default=None, description="The price of the delivery fee for the order (user for ROD orders)")
    small_order_fee: Optional[GenericPosApiPrice] = Field(default=None, description="The price of the small order fee in case the order is small (user for ROD orders)")
    service_fee: Optional[GenericPosApiPrice] = Field(default=None, description="The price of the service fee collected")
    user_note: Optional[StrictStr] = Field(default=None, description="User note for the order.")
    order_source: Optional[StrictStr] = Field(default=None, description="The entity sending the order - always has the value 'Bolt'")
    pick_up_ts: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The UNIX timestamp in **seconds** when the order will be picked up")
    dine_in_details: Optional[GenericPosDineInDetails] = Field(default=None, description="A `GenericPosDineInDetails` object containing the extra order details needed for dine-in functionality (see Dine In Order Integration for more info - you can enable this functionality by contacting Bolt Food)")
    max_acceptance_ts: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The UNIX timestamp in **seconds** value representing the final moment when the order can be accepted. Thus, afterwards the order will fail with the reason DID NOT RESPOND. This field can be enabled by contacting Bolt Food.")
    total_overbooking_amount: Optional[GenericPosPrice] = Field(default=None, description="The total overbooking amount for the order")
    __properties: ClassVar[List[str]] = ["provider_id", "order_id", "extended_order_id", "order_reference_id", "order_type", "order_dispatch_type", "payment_type", "created_ts", "created_datetime", "due_ts", "due_datetime", "customer", "items", "total_order_price", "delivery_fee", "small_order_fee", "service_fee", "user_note", "order_source", "pick_up_ts", "dine_in_details", "max_acceptance_ts", "total_overbooking_amount"]

    @field_validator('order_type')
    def order_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['delivery', 'pickup', 'own_delivery']):
            raise ValueError("must be one of enum values ('delivery', 'pickup', 'own_delivery')")
        return value

    @field_validator('order_dispatch_type')
    def order_dispatch_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['regular', 'scheduled']):
            raise ValueError("must be one of enum values ('regular', 'scheduled')")
        return value

    @field_validator('payment_type')
    def payment_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['cash', 'card_online']):
            raise ValueError("must be one of enum values ('cash', 'card_online')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PostSendNewOrderRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of customer
        if self.customer:
            _dict['customer'] = self.customer.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in items (list)
        _items = []
        if self.items:
            for _item_items in self.items:
                if _item_items:
                    _items.append(_item_items.to_dict())
            _dict['items'] = _items
        # override the default output from pydantic by calling `to_dict()` of total_order_price
        if self.total_order_price:
            _dict['total_order_price'] = self.total_order_price.to_dict()
        # override the default output from pydantic by calling `to_dict()` of delivery_fee
        if self.delivery_fee:
            _dict['delivery_fee'] = self.delivery_fee.to_dict()
        # override the default output from pydantic by calling `to_dict()` of small_order_fee
        if self.small_order_fee:
            _dict['small_order_fee'] = self.small_order_fee.to_dict()
        # override the default output from pydantic by calling `to_dict()` of service_fee
        if self.service_fee:
            _dict['service_fee'] = self.service_fee.to_dict()
        # override the default output from pydantic by calling `to_dict()` of dine_in_details
        if self.dine_in_details:
            _dict['dine_in_details'] = self.dine_in_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of total_overbooking_amount
        if self.total_overbooking_amount:
            _dict['total_overbooking_amount'] = self.total_overbooking_amount.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PostSendNewOrderRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "provider_id": obj.get("provider_id"),
            "order_id": obj.get("order_id"),
            "extended_order_id": obj.get("extended_order_id"),
            "order_reference_id": obj.get("order_reference_id"),
            "order_type": obj.get("order_type"),
            "order_dispatch_type": obj.get("order_dispatch_type"),
            "payment_type": obj.get("payment_type"),
            "created_ts": obj.get("created_ts"),
            "created_datetime": obj.get("created_datetime"),
            "due_ts": obj.get("due_ts"),
            "due_datetime": obj.get("due_datetime"),
            "customer": GenericPosUserInfo.from_dict(obj["customer"]) if obj.get("customer") is not None else None,
            "items": [GenericPosItem.from_dict(_item) for _item in obj["items"]] if obj.get("items") is not None else None,
            "total_order_price": GenericPosApiPrice.from_dict(obj["total_order_price"]) if obj.get("total_order_price") is not None else None,
            "delivery_fee": GenericPosApiPrice.from_dict(obj["delivery_fee"]) if obj.get("delivery_fee") is not None else None,
            "small_order_fee": GenericPosApiPrice.from_dict(obj["small_order_fee"]) if obj.get("small_order_fee") is not None else None,
            "service_fee": GenericPosApiPrice.from_dict(obj["service_fee"]) if obj.get("service_fee") is not None else None,
            "user_note": obj.get("user_note"),
            "order_source": obj.get("order_source"),
            "pick_up_ts": obj.get("pick_up_ts"),
            "dine_in_details": GenericPosDineInDetails.from_dict(obj["dine_in_details"]) if obj.get("dine_in_details") is not None else None,
            "max_acceptance_ts": obj.get("max_acceptance_ts"),
            "total_overbooking_amount": GenericPosPrice.from_dict(obj["total_overbooking_amount"]) if obj.get("total_overbooking_amount") is not None else None
        })
        return _obj


