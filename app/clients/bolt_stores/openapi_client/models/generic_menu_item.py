# coding: utf-8

"""
    BoltStoresAPI

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.generic_localised_field import GenericLocalisedField
from openapi_client.models.generic_menu_item_constraint import GenericMenuItemConstraint
from openapi_client.models.generic_menu_item_fee import GenericMenuItemFee
from openapi_client.models.generic_menu_item_fee_info import GenericMenuItemFeeInfo
from openapi_client.models.generic_menu_item_image_info import GenericMenuItemImageInfo
from openapi_client.models.generic_menu_item_timetable import GenericMenuItemTimetable
from openapi_client.models.tag_multiplier import TagMultiplier
from typing import Optional, Set
from typing_extensions import Self

class GenericMenuItem(BaseModel):
    """
    GenericMenuItem
    """ # noqa: E501
    type: StrictStr = Field(description="Menu item type")
    name: List[GenericLocalisedField] = Field(description="Menu item name")
    description: Optional[List[GenericLocalisedField]] = Field(default=None, description="Menu item description")
    children_ids: Optional[List[StrictStr]] = Field(default=None, description="Contains the list of child menu item id (e.g. dishes can have option groups under them).")
    price: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Required for dishes, options and fees. Currency will be specified by Bolt Food. Prices will be rounded down to 2 decimal in case they will be sent with more than 2 decimals.")
    images: Optional[List[GenericMenuItemImageInfo]] = Field(default=None, description="For dishes, you can add images that will be displayed in the client app on the menu. Size: the minimum recommended height and width of the image is 1200px, up to 10mb.")
    timetables: Optional[List[GenericMenuItemTimetable]] = None
    tags: Optional[List[StrictStr]] = Field(default=None, description="Optional for dishes or options. The usage of some tags may result in side effects regarding the structure of an order, as documented in [Menu Integration guide](/delivery/main/#tag/Doc-Menu-integration).<br><br> The following tags are *deprecated*, please use [fees](/delivery/main/#tag/Doc-Menu-integration/Fees) instead: `bottle_deposit`, `sup_cup`, `sup_container`.<br><br> The `age_restriction_alcohol_pl` is only valid in Poland.")
    tag_multipliers: Optional[List[TagMultiplier]] = Field(default=None, description="This property is now *deprecated*, please use [fees](/delivery/main/#tag/Doc-Menu-integration/Fees) instead. Array used in order to denote how many tag instances are attached to a single item. Applies only on SUP directive business tags.")
    sku: Optional[StrictStr] = Field(default=None, description="The SKU (stock keeping unit) must be specified for all options, dishes and fees. Needed for integrator to identify the items when order is sent. ")
    constraints: Optional[GenericMenuItemConstraint] = None
    fees: Optional[List[GenericMenuItemFee]] = Field(default=None, description="Array used to define any fees applicable on the current item when being ordered. Prices of the attached fee items are shown separately in the Bolt Food application within the product page, and are added on top of the price of the item when computing the total price of the basket.")
    fee_info: Optional[GenericMenuItemFeeInfo] = None
    __properties: ClassVar[List[str]] = ["type", "name", "description", "children_ids", "price", "images", "timetables", "tags", "tag_multipliers", "sku", "constraints", "fees", "fee_info"]

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['menu', 'dish', 'category', 'option_select', 'option_select_group', 'option_multi_select', 'option_multi_select_group', 'option_counter', 'option_counter_group', 'fee']):
            raise ValueError("must be one of enum values ('menu', 'dish', 'category', 'option_select', 'option_select_group', 'option_multi_select', 'option_multi_select_group', 'option_counter', 'option_counter_group', 'fee')")
        return value

    @field_validator('tags')
    def tags_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['spicy', 'spicy3', 'vegan', 'vegetarian', 'kosher', 'halal', 'gluten_free', 'lactose_free', 'children', 'alco', 'special_offer', 'no_discounts', 'bottle_deposit', 'donation', 'packaging_fee', 'sup_cup', 'sup_container', 'special_offer_5', 'special_offer_10', 'special_offer_15', 'special_offer_20', 'special_offer_25', 'special_offer_30', 'special_offer_35', 'special_offer_40', 'special_offer_45', 'special_offer_50', 'age_restriction_alcohol_pl', 'bulky']):
                raise ValueError("each list item must be one of ('spicy', 'spicy3', 'vegan', 'vegetarian', 'kosher', 'halal', 'gluten_free', 'lactose_free', 'children', 'alco', 'special_offer', 'no_discounts', 'bottle_deposit', 'donation', 'packaging_fee', 'sup_cup', 'sup_container', 'special_offer_5', 'special_offer_10', 'special_offer_15', 'special_offer_20', 'special_offer_25', 'special_offer_30', 'special_offer_35', 'special_offer_40', 'special_offer_45', 'special_offer_50', 'age_restriction_alcohol_pl', 'bulky')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GenericMenuItem from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in name (list)
        _items = []
        if self.name:
            for _item_name in self.name:
                if _item_name:
                    _items.append(_item_name.to_dict())
            _dict['name'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in description (list)
        _items = []
        if self.description:
            for _item_description in self.description:
                if _item_description:
                    _items.append(_item_description.to_dict())
            _dict['description'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in images (list)
        _items = []
        if self.images:
            for _item_images in self.images:
                if _item_images:
                    _items.append(_item_images.to_dict())
            _dict['images'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in timetables (list)
        _items = []
        if self.timetables:
            for _item_timetables in self.timetables:
                if _item_timetables:
                    _items.append(_item_timetables.to_dict())
            _dict['timetables'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in tag_multipliers (list)
        _items = []
        if self.tag_multipliers:
            for _item_tag_multipliers in self.tag_multipliers:
                if _item_tag_multipliers:
                    _items.append(_item_tag_multipliers.to_dict())
            _dict['tag_multipliers'] = _items
        # override the default output from pydantic by calling `to_dict()` of constraints
        if self.constraints:
            _dict['constraints'] = self.constraints.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in fees (list)
        _items = []
        if self.fees:
            for _item_fees in self.fees:
                if _item_fees:
                    _items.append(_item_fees.to_dict())
            _dict['fees'] = _items
        # override the default output from pydantic by calling `to_dict()` of fee_info
        if self.fee_info:
            _dict['fee_info'] = self.fee_info.to_dict()
        # set to None if sku (nullable) is None
        # and model_fields_set contains the field
        if self.sku is None and "sku" in self.model_fields_set:
            _dict['sku'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GenericMenuItem from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "type": obj.get("type"),
            "name": [GenericLocalisedField.from_dict(_item) for _item in obj["name"]] if obj.get("name") is not None else None,
            "description": [GenericLocalisedField.from_dict(_item) for _item in obj["description"]] if obj.get("description") is not None else None,
            "children_ids": obj.get("children_ids"),
            "price": obj.get("price"),
            "images": [GenericMenuItemImageInfo.from_dict(_item) for _item in obj["images"]] if obj.get("images") is not None else None,
            "timetables": [GenericMenuItemTimetable.from_dict(_item) for _item in obj["timetables"]] if obj.get("timetables") is not None else None,
            "tags": obj.get("tags"),
            "tag_multipliers": [TagMultiplier.from_dict(_item) for _item in obj["tag_multipliers"]] if obj.get("tag_multipliers") is not None else None,
            "sku": obj.get("sku"),
            "constraints": GenericMenuItemConstraint.from_dict(obj["constraints"]) if obj.get("constraints") is not None else None,
            "fees": [GenericMenuItemFee.from_dict(_item) for _item in obj["fees"]] if obj.get("fees") is not None else None,
            "fee_info": GenericMenuItemFeeInfo.from_dict(obj["fee_info"]) if obj.get("fee_info") is not None else None
        })
        return _obj


