# coding: utf-8

"""
    BoltStoresAPI

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from openapi_client.models.categories_inner import CategoriesInner
from openapi_client.models.fees_inner import FeesInner
from openapi_client.models.selling_unit import SellingUnit
from typing import Optional, Set
from typing_extensions import Self

class PimCreateProductParams(BaseModel):
    """
    Information regarding new products
    """ # noqa: E501
    sku: Annotated[str, Field(min_length=1, strict=True, max_length=255)] = Field(description="A unique string identifier of a product (stands for a “Stock Keeping Unit”) ")
    name: Dict[str, StrictStr] = Field(description="A dictionary that contains translations to several languages.  Keys are locales (\"en-US\", \"ro-RO\", etc.), values are translations.  Example: `{ \"en-US\": \"Milk\", \"ee-EE\": \"Piim\" }` ")
    categories: Optional[List[CategoriesInner]] = Field(default=None, description="An array of categories the product belongs to, referenced by names of category and subacategory in the default locale (`en-US`). Either `categories` or `category_external_ids` **MUST** be specified for a new product (the former takes precedence if both are present).")
    category_external_ids: Optional[List[Annotated[str, Field(min_length=1, strict=True, max_length=255)]]] = Field(default=None, description="An array of categories the product belongs to, referenced by subcategory `external_id`. Either `categories` or `category_external_ids` **MUST** be specified for a new product (the former takes precedence if both are present).")
    provider_ids: Optional[List[StrictStr]] = Field(default=None, description="An array of identifiers of providers that are selling the item. If some provider is not listed, the product will not be on the corresponding menu.  Please note that excluding some provider does not automatically result in delisting a product from this provider's menu if the product has a non-zero stock balance in the store. The product will only disappear from menu when the stock balance has become nil.  If this value is not set, the product will be published in all stores in the region by default. ")
    vat_tag: Optional[StrictStr] = Field(default=None, description="VAT tag of the item. Consult technical support or PIM Web interface for the list of available tags.")
    description: Optional[Dict[str, StrictStr]] = Field(default=None, description="A dictionary that contains translations to several languages.  Keys are locales (\"en-US\", \"ro-RO\", etc.), values are translations.  Example: `{ \"en-US\": \"Milk\", \"ee-EE\": \"Piim\" }` ")
    barcodes: List[Annotated[str, Field(min_length=1, strict=True, max_length=255)]] = Field(description="An array of product's barcodes. Barcodes must be unique across all products ")
    weight_net_gram: Optional[Annotated[int, Field(le=100000, strict=True, ge=0)]] = Field(default=None, description="Product net weight in grams.")
    weight_gross_gram: Optional[Annotated[int, Field(le=100000, strict=True, ge=0)]] = Field(default=None, description="Product gross weight in grams.")
    product_volume_cm3: Optional[Annotated[int, Field(le=1000, strict=True, ge=0)]] = Field(default=None, description="Product volume in cubic centimeters. ")
    product_length_cm: Optional[Annotated[int, Field(le=1000, strict=True, ge=0)]] = Field(default=None, description="Product package length in centimeters.")
    product_width_cm: Optional[Annotated[int, Field(le=1000, strict=True, ge=0)]] = Field(default=None, description="Product package width in centimeters.")
    product_height_cm: Optional[Annotated[int, Field(le=1000, strict=True, ge=0)]] = Field(default=None, description="Product package height in centimeters.")
    order_quantity_limit: Optional[Annotated[int, Field(le=1000, strict=True, ge=0)]] = Field(default=None, description="The maximum amount of items that can be ordered in a single order")
    image_url: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=512)]] = Field(default=None, description="A URL of an image of the SKU. Will be requested by Bolt Server while processing the data. ")
    tags: Optional[List[Annotated[str, Field(min_length=1, strict=True, max_length=255)]]] = Field(default=None, description="An array of tags used to denote certain properties of the item, such as contains alcohol or otherwise restricted. Consult technical support or PIM Web interface regarding the list of available tags ")
    timetables: Optional[List[Annotated[str, Field(min_length=1, strict=True, max_length=255)]]] = Field(default=None, description="For the items that are not generally available during the entire store working hours, contains the references to specific timetable(s). See the  [Bulk import timetables](#tag/PIM-integration:-Products/operation/post-pimV1TimetableCreateInBatch)  and  [Retrieve timetable list](#tag/PIM-integration:-Products/operation/post-pimV1TimetableList)  endpoints ")
    option_groups: Optional[List[Annotated[str, Field(min_length=1, strict=True, max_length=255)]]] = Field(default=None, description="An array of external IDs of option groups that are to be associated with this item. ")
    fees: Optional[List[FeesInner]] = Field(default=None, description="An array of fees that are to be associated with this item. ")
    is_measured: Optional[StrictBool] = Field(default=None, description="Flag to control whether the item is weighted (measured). Beware that the `product_main_measure` value must be available if you want to set the item as weighted. Thus, you are expected to provide `product_main_measure` (both `value` and `unit`) when this flag is `true`. Otherwise, the import process will be terminated with a `Validation Error`. If the flag value is not provided within the Create Import process, then the product will by default be configured as non-weighted. Within the Update Import Process, the product will remain as is if the flag is left empty")
    product_main_measure: Optional[Dict[str, Any]] = Field(default=None, description="Main Measure for the Product: For weighted items, this setting allows you to specify an increment for item quantity in the Bolt Food app. The main measure for the product must be specified and synchronized if the item is weighted. For example, if `is_measured` is `true`, then the product's main measure should be one of the measured units: `gram`, `kg`, `millilitre`, or `litre`. Possible values for unit:   - piece   - gram   - millilitre   - kg   - litre  Example: `{ \"unit\": \"kg\", \"value\": \"0.5\" }` ")
    selling_unit: Optional[SellingUnit] = None
    __properties: ClassVar[List[str]] = ["sku", "name", "categories", "category_external_ids", "provider_ids", "vat_tag", "description", "barcodes", "weight_net_gram", "weight_gross_gram", "product_volume_cm3", "product_length_cm", "product_width_cm", "product_height_cm", "order_quantity_limit", "image_url", "tags", "timetables", "option_groups", "fees", "is_measured", "product_main_measure", "selling_unit"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PimCreateProductParams from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in categories (list)
        _items = []
        if self.categories:
            for _item_categories in self.categories:
                if _item_categories:
                    _items.append(_item_categories.to_dict())
            _dict['categories'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in fees (list)
        _items = []
        if self.fees:
            for _item_fees in self.fees:
                if _item_fees:
                    _items.append(_item_fees.to_dict())
            _dict['fees'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PimCreateProductParams from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "sku": obj.get("sku"),
            "name": obj.get("name"),
            "categories": [CategoriesInner.from_dict(_item) for _item in obj["categories"]] if obj.get("categories") is not None else None,
            "category_external_ids": obj.get("category_external_ids"),
            "provider_ids": obj.get("provider_ids"),
            "vat_tag": obj.get("vat_tag"),
            "description": obj.get("description"),
            "barcodes": obj.get("barcodes"),
            "weight_net_gram": obj.get("weight_net_gram"),
            "weight_gross_gram": obj.get("weight_gross_gram"),
            "product_volume_cm3": obj.get("product_volume_cm3"),
            "product_length_cm": obj.get("product_length_cm"),
            "product_width_cm": obj.get("product_width_cm"),
            "product_height_cm": obj.get("product_height_cm"),
            "order_quantity_limit": obj.get("order_quantity_limit"),
            "image_url": obj.get("image_url"),
            "tags": obj.get("tags"),
            "timetables": obj.get("timetables"),
            "option_groups": obj.get("option_groups"),
            "fees": [FeesInner.from_dict(_item) for _item in obj["fees"]] if obj.get("fees") is not None else None,
            "is_measured": obj.get("is_measured"),
            "product_main_measure": obj.get("product_main_measure"),
            "selling_unit": obj.get("selling_unit")
        })
        return _obj


